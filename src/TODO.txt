
- zaimplementować GreedyStringTiling i przetestować dla testowych stringów - https://github.com/arunjeyapal/GreedyStringTiling
- zmienić tokeny na stringi (jeśli się da), jeśli nie to dać możliwość zamiany tokenów na stringi
- dodać do TokenLine number:
	+ numer pierwszy token w linijki względem całego pliku
	+ numer znormalizowanej linii względem całego znormalizowanego pliku
- dodać do TokenFile metodę tworzącą jeden długi ciąg stringów z tokenów oddzielonych spacjami
- sprawdzić działanie GreedyStringTiling (pattern - pierwszy strumień tokenów; text - drugi stumień tokenów)
- zapisać podobieństwo i znalezione fragmenty

- zrobić taką samą kolejność File1, File2 dla wszystkich trzech okien
- w przypadku wyłączenia typu tokena zastąpić go tokenem Unknown; w jednym ciągu tokenów użyć Unknown1, w drugim Unknown2, dzięki temu tokeny Unknown nie będą używane przy porównaniu

4. Algorytm:
- algorytm porównujący:
    + np. Karp-Rabin algorithm - porównać mniejszy string z większym, Rabin fingerprint, Dynamic pattern matching and hashing to B buckets
    + bierze pod uwagę minimalną długość fragmentu
    + raz znalezione tokeny, nie mogą być użyte ponownie (w obydwu porównywanych plikach - UWAGA przy usuwaniu, żeby nie traktowało części kodu z przed i po usunięciu jako spójny)


5. Testy
- napisać testy:
    + normalizacji kodu
    + tokenizacji:
        - scalic kilka plikow z roznych zrodel w jedne plik z kilkoma tysiacami linii kodu
        - umiescic ten plik w projekcie
        - przygotowac test tokenizacji
        - wykorzystać token UNKNOWN
    + wykrywania plagiatu


6. Rodzaje tokenizacji:
- znaleźć dużą liczbę podobnych prac (spytać prowadzącego, poszukać na internecie, poszukać w innych pracach o podobnej tematyce)
- wybor tokenów jakie mają być używane - UWAGA przy wyłączaniu tokenów wpływających na wykrywanie funkcji i operatorów np. arytmentycznych
- rodzaje:
    + ogólna np. LICZBA = float, double, int, long, short
    + prezycyjna np. INT = int; class(int a, float b) - rozróżniać argumenty i kolejność argumentów jest ustalana na podstawie kolejności sprawdzania typów argumentów
    + "branie/nie branie" pod uwagę początek { i koniec } np. BEGIN_CLASS, END_CLASS; sprawdzić przykład z JPlag
    + "branie/nie branie" pod uwagę argumentow w np. if(), for(), while()
    + "branie/nie branie" pod uwage argumentow w definicjach u wywolaniach funkcji 


7. Rozbudowa:
- help - opis wszystkiego m.in. co oznaczają poszczególne kolumny tabel
- zrobić metodę 1 do 1
- CompareFiles - wyświetlić długość najdłuższego znalezionego podobnego fragmentu
- branie pod uwagę procentowego podobieństwa fragmentów (niepodobny kod na początku i końcu fragmentu jest pomijany) + zaimplementować ustawienia
- wyświetlanie tylko par plików z minimalnym procentem podobieństwa
- zmodyfikowac algorytm karpa-rabina

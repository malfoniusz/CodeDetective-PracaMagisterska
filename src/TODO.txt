
3. Tokenizacja pliku:
- spis tokenów:
    + String, char - TEXT
    + byte - BYTE
    + int[] a, String[] s - TABLE
    + String[][] ss - TABLE TABLE
    
    + https://www.tutorialspoint.com/java/java_basic_operators.htm
    + int i = 0 - NUMBER, ASSIGN

    + if, else if, else, switch - CONDITIONAL (pominąć warunki wewnątrz)
    + for, while, do while - LOOP
    + try, catch - EXCEPTION
    
    + class Foo - CLASS,
    + MyClass myClass = new MyClass() - VAR, ASSIGN
    + public Konstruktor() - CONSTRUCTOR
    
    + static - STATIC
    + final - FINAL
    + extends, implements - ???
    
    + void funkcja() - FUNCTION_DEF
    + void funkcja(int a, String b) - FUNCTION_DEF, ARG, ARG
    + funkcja() - FUNCTION_USE
    + System.out.println() - FUNCTION_USE
    + System.out.println("hejka") - FUNCTION_USE, ARG
- sprawdzić instrukcje w javie pod kątem czyszczenia kodu i tokenizacji
- przetestowac tokenizacje dla pojedynczych plikow od różnych osób (wyświetlić i sprawdzić poprawność tokenizacji)


4. Algorytm:
- opcje - wybór minimalnej długości łańcuchów
- algorytm porównujący:
    + zasada działania:
        - z pary plików otrzymujemy dwa gigantyczne ciągi tokenów
        - szukamy takich samych fragmentów tokenów pomiędzy obydwoma ciągami, np. Rabin–Karp algorithm - porównać mniejszy string z większym, Rabin fingerprint, Dynamic pattern matching and hashing to B buckets
        - przeszukujemy gigantyczne ciągi i osobno zliczamy liczbę podobnych linii kodu (puste linii lub zawierające tylko nawias klamrowy, nie zaliczać do podobnych linii)
    + bierze pod uwagę minimalną długość fragmentu
    + raz znalezione identyczne tokeny, nie mogą być użyte do dalszych porównań
    + bierze pod uwagę procentowe podobieństwo fragmentów (niepodobny kod na początku i końcu fragmentu jest pomijany)
    + zwraca dane (numery linii z podobnymi fragmentami kodów)
- (w przypadku zbyt dużej liczby fałszywych wyników):
    + sprecyzować tokeny: NUMBER - NUMBER_WHOLE, NUMBER_DECIMAL - INT, LONG, FLOAT, DOUBLE
    + sprawdzać argumenty w definiowanych i wywoływanych funkcjach i klasach - sprawdzać również kolejność argumentów
    + sprawdzać argumenty w warunkach, np. if (i < 10), while (x == 0)
- opcje(2):
    + wybór procentu podobieństwa łańcuchów
    + wyświetlanie tylko par plików z minimalnym procentem podobieństwa
- help - opis wszystkiego m.in. kolumn tabel

5. Rozbudowa:
- zmniejszyć interfejs
- zmiana ustawień np. minimalna długość fragmentu
- rodzaje tokenizacji
	+ normalna np. LICZBA = int, long, short
	+ ogólna np. LICZBA = float, double, int, long, short
	+ prezycyjna np. INT = int
	+ biorąca pod uwagę początek i koniec np. BEGIN_CLASS, END_CLASS; sprawdzić przykład z JPlag
- zmodyfikowac algorytm karpa-rabina (zeby bylo cos zrobionego wlasnego w tej pracy)

X. Dodatkowe pomysły:
- wyświetlenie paska postępu i przeminiętego czasu
- statystyki (czas wykonania programu, liczba identycznych tokenów, inne)
- dodatkowe sprawdzenie wynikow - dla linii kodu wykrytych jako podobne (tokeny), sprawdzić czy ich kod jest taki sam (jeśli taki sam to bardziej prawdopodobne, że plagiat)
- usuniecie niebezpiecznych znaków przed tokenizacja (twarda spacja, nieznane znaki unicode)
- poprawic normalizacje kodu: usuwanie komentarzy i instrukcje kilkulinijkowe

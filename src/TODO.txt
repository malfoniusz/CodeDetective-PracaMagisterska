
- poprawić szukanie tokenow dla [] i wszystkiego ponizej; nie wykrywa [2]; latwo oszukac np. int areturn;

3. Tokenizacja pliku:
- spis tokenów:
    + MyClass myClass - CLASS_VAR
    + MyClass myClass = new MyClass() - CLASS_VAR, ASSIGN, NEW?
    
    + funkcja() - FUNCTION_USE
    + System.out.println("hejka") - FUNCTION_USE
- poszukac w Internecie innych Tokenow do Javy
- przetestowac tokenizacje dla plikow od różnych osób (wyświetlić i sprawdzić poprawność tokenizacji)


4. Algorytm:
- opcje - wybór minimalnej długości łańcuchów
- algorytm porównujący:
    + zasada działania:
        - z pary plików otrzymujemy dwa gigantyczne ciągi tokenów
        - szukamy takich samych fragmentów tokenów pomiędzy obydwoma ciągami, np. Rabin–Karp algorithm - porównać mniejszy string z większym, Rabin fingerprint, Dynamic pattern matching and hashing to B buckets
        - przeszukujemy gigantyczne ciągi i osobno zliczamy liczbę podobnych linii kodu (puste linii lub zawierające tylko nawias klamrowy, nie zaliczać do podobnych linii)
    + bierze pod uwagę minimalną długość fragmentu
    + raz znalezione identyczne tokeny, nie mogą być użyte do dalszych porównań
    + bierze pod uwagę procentowe podobieństwo fragmentów (niepodobny kod na początku i końcu fragmentu jest pomijany)
    + zwraca dane (numery linii z podobnymi fragmentami kodów)
- (w przypadku zbyt dużej liczby fałszywych wyników):
    + sprecyzować tokeny: NUMBER - NUMBER_WHOLE, NUMBER_DECIMAL - INT, LONG, FLOAT, DOUBLE
    + sprawdzać argumenty w definiowanych i wywoływanych funkcjach i klasach - sprawdzać również kolejność argumentów
    + sprawdzać argumenty w warunkach, np. if (i < 10), while (x == 0)
- opcje(2):
    + wybór procentu podobieństwa łańcuchów
    + wyświetlanie tylko par plików z minimalnym procentem podobieństwa
- help - opis wszystkiego m.in. kolumn tabel

5. Rozbudowa:
- zmniejszyć interfejs
- zmiana ustawień np. minimalna długość fragmentu
- modyfikacje tokenizacji
	+ ogólna np. LICZBA = float, double, int, long, short
	+ prezycyjna np. INT = int; class(int a, float b) - rozróżniać argumenty i kolejność argumentów jest ustalana na podstawie kolejności sprawdzania typów argumentów
	+ "branie/nie branie" pod uwagę początek { i koniec } np. BEGIN_CLASS, END_CLASS; sprawdzić przykład z JPlag
	+ "branie/nie branie" pod uwagę argumentow w np. if(), for(), while()
	+ "branie/nie branie" pod uwage argumentow w definicjach u wywolaniach funkcji 
- zmodyfikowac algorytm karpa-rabina (zeby bylo cos zrobionego wlasnego w tej pracy)

